diff --git a/convert.c b/convert.c
index c7d6a85..f3db530 100644
--- a/convert.c
+++ b/convert.c
@@ -6,6 +6,7 @@
 #include "config.h"
 #include "convert.h"
 #include "copy.h"
+#include "environment.h"
 #include "gettext.h"
 #include "hex.h"
 #include "object-file.h"
@@ -19,6 +20,10 @@
 #include "trace.h"
 #include "utf8.h"
 #include "merge-ll.h"
+#ifdef __MVS__
+#include <_Ccsid.h>
+#include "read-cache-ll.h"
+#endif
 
 /*
  * convert.c - convert a file when checking it out and checking it in.
@@ -385,12 +390,16 @@ static int check_roundtrip(const char *enc_name)
 static const char *default_encoding = "UTF-8";
 
 static int encode_to_git(const char *path, const char *src, size_t src_len,
-			 struct strbuf *buf, const char *enc, int conv_flags)
+			 struct strbuf *buf, const char *enc,
+			 enum convert_crlf_action attr_action, int conv_flags)
 {
 	char *dst;
 	size_t dst_len;
 	int die_on_error = conv_flags & CONV_WRITE_OBJECT;
 
+	if (attr_action == CRLF_BINARY) {
+		return 0;
+	}
 	/*
 	 * No encoding is specified or there is nothing to encode.
 	 * Tell the caller that the content was not modified.
@@ -411,6 +420,12 @@ static int encode_to_git(const char *path, const char *src, size_t src_len,
 		return 0;
 
 	trace_encoding("source", path, enc, src, src_len);
+#ifdef __MVS__
+  // If UTF CCSID == 819 (ISO8859-1), do not convert ISO8859-1 tagged files
+  if (utf8_ccsid == 819 && strcasecmp("ISO8859-1", enc) == 0)
+	return 0;
+#endif
+
 	dst = reencode_string_len(src, src_len, default_encoding, enc,
 				  &dst_len);
 	if (!dst) {
@@ -420,6 +435,9 @@ static int encode_to_git(const char *path, const char *src, size_t src_len,
 		 * would fail and we would leave the user with a messed-up
 		 * working tree. Let's try to avoid this by screaming loud.
 		 */
+	       if (attr_action == CRLF_BINARY) {
+			return 0;
+		}
 		const char* msg = _("failed to encode '%s' from %s to %s");
 		if (die_on_error)
 			die(msg, path, enc, default_encoding);
@@ -476,10 +494,14 @@ static int encode_to_git(const char *path, const char *src, size_t src_len,
 }
 
 static int encode_to_worktree(const char *path, const char *src, size_t src_len,
-			      struct strbuf *buf, const char *enc)
+			      struct strbuf *buf, enum convert_crlf_action attr_action,
+			      const char *enc)
 {
 	char *dst;
 	size_t dst_len;
+if (attr_action == CRLF_BINARY) {
+    return 0;
+}
 
 	/*
 	 * No encoding is specified or there is nothing to encode.
@@ -1316,18 +1338,40 @@ static int git_path_check_ident(struct attr_check_item *check)
 
 static struct attr_check *check;
 
+static const char *get_platform(void)
+{
+	static char platform_name[64];
+	struct utsname uname_info;
+
+	if (uname(&uname_info))
+		die(_("uname() failed with error '%s' (%d)"),
+			strerror(errno),
+			errno);
+
+	/* Map OS/390 to 'zos' for platform-specific encoding attributes */
+	if (!strcmp(uname_info.sysname, "OS/390"))
+		return "zos";
+	
+	xsnprintf(platform_name, sizeof(platform_name), "%s", uname_info.sysname);
+	return platform_name;
+}
+
 void convert_attrs(struct index_state *istate,
 		   struct conv_attrs *ca, const char *path)
 {
 	struct attr_check_item *ccheck = NULL;
+	struct strbuf platform_working_tree_encoding = STRBUF_INIT;
+	strbuf_addf(&platform_working_tree_encoding, "%s-working-tree-encoding", get_platform());
 
 	if (!check) {
 		check = attr_check_initl("crlf", "ident", "filter",
 					 "eol", "text", "working-tree-encoding",
+					 platform_working_tree_encoding.buf,
 					 NULL);
 		user_convert_tail = &user_convert;
 		repo_config(the_repository, read_convert_config, NULL);
 	}
+	strbuf_release(&platform_working_tree_encoding);
 
 	git_check_attr(istate, path, check);
 	ccheck = check->items;
@@ -1348,6 +1392,8 @@ void convert_attrs(struct index_state *istate,
 			ca->crlf_action = CRLF_TEXT_CRLF;
 	}
 	ca->working_tree_encoding = git_path_check_encoding(ccheck + 5);
+	if (git_path_check_encoding(ccheck + 6))
+	    ca->working_tree_encoding = git_path_check_encoding(ccheck + 6);
 
 	/* Save attr and make a decision for action */
 	ca->attr_action = ca->crlf_action;
@@ -1444,7 +1490,7 @@ int convert_to_git(struct index_state *istate,
 		len = dst->len;
 	}
 
-	ret |= encode_to_git(path, src, len, dst, ca.working_tree_encoding, conv_flags);
+	ret |= encode_to_git(path, src, len, dst, ca.working_tree_encoding, ca.attr_action, conv_flags);
 	if (ret && dst) {
 		src = dst->buf;
 		len = dst->len;
@@ -1472,7 +1518,7 @@ void convert_to_git_filter_fd(struct index_state *istate,
 	if (!apply_filter(path, NULL, 0, fd, dst, ca.drv, CAP_CLEAN, NULL, NULL))
 		die(_("%s: clean filter '%s' failed"), path, ca.drv->name);
 
-	encode_to_git(path, dst->buf, dst->len, dst, ca.working_tree_encoding, conv_flags);
+	encode_to_git(path, dst->buf, dst->len, dst, ca.working_tree_encoding, ca.attr_action, conv_flags);
 	crlf_to_git(istate, path, dst->buf, dst->len, dst, ca.crlf_action, conv_flags);
 	ident_to_git(dst->buf, dst->len, dst, ca.ident);
 }
@@ -1504,7 +1550,7 @@ static int convert_to_working_tree_ca_internal(const struct conv_attrs *ca,
 		}
 	}
 
-	ret |= encode_to_worktree(path, src, len, dst, ca->working_tree_encoding);
+	ret |= encode_to_worktree(path, src, len, dst, ca->attr_action, ca->working_tree_encoding);
 	if (ret) {
 		src = dst->buf;
 		len = dst->len;
@@ -2058,3 +2104,84 @@ enum conv_attrs_classification classify_conv_attrs(const struct conv_attrs *ca)
 
 	return CA_CLASS_STREAMABLE;
 }
+
+
+#ifdef __MVS__
+
+void tag_file_as_working_tree_encoding(struct index_state *istate, char* path, int fd) {
+        struct conv_attrs ca;
+        convert_attrs(istate, &ca, path);
+  if (ca.attr_action != CRLF_BINARY) {
+    if (ca.working_tree_encoding)
+      __chgfdcodeset(fd, ca.working_tree_encoding);
+    else
+      __chgfdccsid(fd, utf8_ccsid);
+  }
+  else {
+    __setfdbinary(fd);
+  }
+
+  __disableautocvt(fd);
+}
+
+void validate_codeset(struct index_state *istate, const char *path, int* autoconvertToASCII) {
+	struct conv_attrs ca;
+	struct stat st;
+	unsigned short attr_ccsid;
+	unsigned short file_ccsid;
+
+	if (ignore_file_tags) {
+		*autoconvertToASCII = 0;
+		return;
+	}
+
+	*autoconvertToASCII = 0;
+	convert_attrs(istate, &ca, path);
+	if (ca.attr_action == CRLF_BINARY) {
+		attr_ccsid = FT_BINARY;
+	}
+	else if (ca.working_tree_encoding) {
+		attr_ccsid = __toCcsid(ca.working_tree_encoding);
+	}
+	else {
+		attr_ccsid = utf8_ccsid;
+	}
+
+	if (stat(path, &st) < 0)
+		return;
+
+	file_ccsid = st.st_tag.ft_ccsid;
+
+	if (file_ccsid == FT_UNTAGGED) {
+		die("File %s is untagged, set the correct file tag (using the chtag command).", path);
+	}
+
+	if (attr_ccsid != file_ccsid) {
+		if (file_ccsid == 1047 && attr_ccsid == 819) {
+			*autoconvertToASCII = 1;
+			return;
+		}
+		// Allow tag mixing of 819 and 1208
+		if ((file_ccsid == 819 || file_ccsid == 1208) && (attr_ccsid == 1208 || attr_ccsid == 819)) {
+			return;
+		}
+		// Don't check for binary files, just add them
+		if (attr_ccsid == FT_BINARY)
+			return;
+
+		char attr_csname[_XOPEN_PATH_MAX] = {0};
+		char file_csname[_XOPEN_PATH_MAX] = {0};
+		if (attr_ccsid != FT_BINARY) {
+			__toCSName(attr_ccsid, attr_csname);
+		} else {
+			snprintf(attr_csname, _XOPEN_PATH_MAX, "%s", "binary");
+		}
+		if (file_ccsid != FT_BINARY) {
+			__toCSName(file_ccsid, file_csname);
+		} else {
+			snprintf(file_csname, _XOPEN_PATH_MAX, "%s", "binary");
+		}
+		die("%s added file: file tag (%s) does not match working-tree-encoding (%s)", path, file_csname, attr_csname);
+	}
+}
+#endif
